(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{239:function(n,t,e){"use strict";e.d(t,"c",(function(){return l})),e.d(t,"f",(function(){return c})),e.d(t,"a",(function(){return f})),e.d(t,"b",(function(){return v})),e.d(t,"e",(function(){return x})),e.d(t,"d",(function(){return y}));e(152);var r=e(24),o=(e(19),e(232),e(17),e(18),e(6),e(46),e(27),e(2),e(3),e(4),e(5),e(248)),h=e.n(o);function l(n,t,e){if(void 0===e&&!(e=Object.getPrototypeOf(n).PROPERTIES[t]))return;return void 0===e.get?e.type(n[t]):e.get.call(n)}function c(n,t,e){var r=new window[n.constructor.name](this,0),o=l(n,t,e),c=l(r,t,e);return h()(o,c,{strict:!0})}function d(n){return"string"==typeof n?(n=n.replace(/\\/g,"\\\\").replace(/"/g,'\\"'),'"'.concat(n,'"')):n.toString()}function f(n,t,e){if(!(t instanceof Object))return"".concat(e,".").concat(n,"(").concat(d(t),")\n");for(var o="",h=0,l=Object.entries(t);h<l.length;h++){var c=Object(r.a)(l[h],2),f=c[0],v=c[1];o+="".concat(e,".").concat(n,"(").concat(d(f),", ").concat(d(v),")\n")}return o}function v(n,t){switch(n.type){case String:return!0===t?"const std::string&":"std::string";case Number:return"float";case Boolean:return"bool";case Object:return"std::unique_ptr<rbjson::Object>";default:return"void* /* TODO: fix type */"}}function x(n,t){switch(n.type){case String:return"string";case Number:return"number";case Boolean:return"boolean";case Object:return"Record<string, any>";default:return"any /* TODO: fix type */"}}function y(n){switch(n.type){case String:case Number:return n.type.name;case Boolean:return"Bool";default:return"Nil/* TODO: fix type */"}}},243:function(n,t,e){var content=e(317);"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,e(60).default)("04d6b118",content,!0,{sourceMap:!1})},254:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(366))},255:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(367))},256:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(368))},257:function(n,t,e){var map={"./06_arm.js":369,"./06_bar.js":371,"./06_button.js":373,"./06_camera.js":375,"./06_checkbox.js":377,"./06_circle.js":379,"./06_input.js":381,"./06_joystick.js":383,"./06_led.js":385,"./06_orientation.js":387,"./06_select.js":389,"./06_slider.js":391,"./06_spinedit.js":393,"./06_switcher.js":395,"./06_text.js":397};function r(n){var t=o(n);return e(t)}function o(n){if(!e.o(map,n)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return map[n]}r.keys=function(){return Object.keys(map)},r.resolve=o,n.exports=r,r.id=257},266:function(n,t,e){"use strict";e(2),e(3),e(4),e(5);var r=e(306),o=e.n(r),h=(e(307),e(309),e(310),e(311),e(312),e(313),e(314)),l=e.n(h),c={props:{value:{type:String,required:!0},language:{type:String,required:!0},title:{type:String,required:!0},hideable:{type:Boolean,required:!1,default:!1},hidden:{type:Boolean,required:!1,default:!0}},data:function(){return{showCode:!this.hideable}},computed:{highlighted:function(){return o.a.highlight(this.value,o.a.languages[this.language],this.language)}},watch:{hidden:{immediate:!0,handler:function(){this.hideable&&this.showCode!==!this.hidden&&(this.showCode=!this.hidden)}}},methods:{onCopyClick:function(){l()(this.value),this.$notify({group:"info",title:"Code copied",text:"The code was copied into your clipboard."})},onShowClick:function(){this.showCode=!this.showCode,this.$emit("update:hidden",!this.showCode)}}},d=(e(316),e(54)),f=e(76),v=e.n(f),x=e(302),y=e(460),w=e(461),m=e(462),component=Object(d.a)(c,(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"d-flex flex-column fill"},[e("v-row",{staticClass:"flex-grow-0",attrs:{dense:"",align:"center"}},[e("v-col",{staticClass:"mx-4 my-2 title shrink text-no-wrap"},[n._v("\n      "+n._s(n.title)+"\n    ")]),n._v(" "),n.hideable?e("v-col",{attrs:{cols:"2"}},[e("v-btn",{attrs:{text:"",block:"",color:"accent"},domProps:{textContent:n._s(n.showCode?"Hide":"Show")},on:{click:n.onShowClick}})],1):n._e(),n._v(" "),e("v-spacer"),n._v(" "),n.showCode?e("v-col",{staticClass:"shrink"},[e("v-btn",{attrs:{text:"",color:"primary"},on:{click:n.onCopyClick}},[n._v("\n        Copy to clipboard\n      ")])],1):n._e()],1),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:n.showCode,expression:"showCode"}],staticClass:"flex-grow-1",staticStyle:{overflow:"hidden"}},[e("pre",{class:"language-"+n.language,staticStyle:{overflow:"auto",height:"100%","font-size":"12px"}},[e("code",{class:["language-"+n.language,"pb-4"],domProps:{innerHTML:n._s(n.highlighted)}})])])],1)}),[],!1,null,"4104968a",null);t.a=component.exports;v()(component,{VBtn:x.a,VCol:y.a,VRow:w.a,VSpacer:m.a})},316:function(n,t,e){"use strict";var r=e(243);e.n(r).a},317:function(n,t,e){(t=e(59)(!1)).push([n.i,'.text-monospace[data-v-4104968a]{font-family:"Lucida Console",Monaco,monospace}.fill[data-v-4104968a]{width:100%;height:100%;overflow:hidden}code[data-v-4104968a]{box-shadow:unset;border-radius:0}code[data-v-4104968a]:before{content:""}pre[data-v-4104968a]{border-radius:0}',""]),n.exports=t},359:function(n,t){},366:function(n,t){n.exports="var ge1doot = ge1doot || {}\nge1doot.canvas = function (elem) {\n  var canvas = { width: 0, height: 0, left: 0, top: 0, ctx: null, elem: null }\n  canvas.elem = elem\n  canvas.elem.onselectstart = function () {\n    return false\n  }\n  canvas.elem.ondragstart = function () {\n    return false\n  }\n  canvas.ctx = canvas.elem.getContext('2d')\n  canvas.dpr = window.devicePixelRatio || 1;\n  canvas.setSize = function () {\n    var o = this.elem\n    var w = this.elem.offsetWidth\n    var h = this.elem.offsetHeight\n    if (w != this.width || h != this.height) {\n      for (this.left = 0, this.top = 0; o != null; o = o.offsetParent) {\n        this.left += o.offsetLeft\n        this.top += o.offsetTop\n      }\n      this.elem.width = w*this.dpr\n      this.elem.height = h*this.dpr\n      this.width = w\n      this.height = h\n      canvas.ctx.scale(this.dpr, this.dpr)\n      this.resize && this.resize()\n    }\n  }\n  canvas.setSize()\n  canvas.pointer = {\n    x: 0,\n    y: 0,\n    dx: 0,\n    dy: 0,\n    startX: 0,\n    startY: 0,\n    canvas: canvas,\n    touchMode: false,\n    isDown: false,\n    center: function (s) {\n      this.dx *= s\n      this.dy *= s\n      endX = endY = 0\n    },\n    sweeping: false\n  }\n  var started = false,\n    endX = 0,\n    endY = 0\n\n  if (window['IN_RB_GRID_DESIGNER'] === true) {\n    return canvas\n  }\n\n  var addEvent = function (elem, e, fn) {\n    for (var i = 0, events = e.split(','); i < events.length; i++) {\n      elem.addEventListener(events[i], fn.bind(canvas.pointer), false)\n    }\n  }\n  addEvent(window, 'mousemove,touchmove', function (e) {\n    this.touchMode = e.targetTouches\n    var pointer = this.touchMode ? this.touchMode[0] : e\n    this.x = pointer.clientX - this.canvas.left\n    this.y = pointer.clientY - this.canvas.top\n    if (started) {\n      e.preventDefault()\n      this.sweeping = true\n      this.dx = endX - (this.x - this.startX)\n      this.dy = endY - (this.y - this.startY)\n    }\n    if (this.move) this.move(e)\n  })\n  addEvent(canvas.elem, 'mousedown,touchstart', function (e) {\n    e.preventDefault()\n    this.touchMode = e.targetTouches\n    var pointer = this.touchMode ? this.touchMode[0] : e\n    this.startX = this.x = pointer.clientX - this.canvas.left\n    this.startY = this.y = pointer.clientY - this.canvas.top\n    started = true\n    this.isDown = true\n    if (this.down) this.down(e)\n    setTimeout(\n      function () {\n        if (\n          !started &&\n          Math.abs(this.startX - this.x) < 11 &&\n          Math.abs(this.startY - this.y) < 11\n        ) {\n          if (this.tap) this.tap(e)\n        }\n      }.bind(this),\n      200\n    )\n  })\n  addEvent(window, 'mouseup,touchend,touchcancel', function (e) {\n    if (started) {\n      e.preventDefault()\n      endX = this.dx\n      endY = this.dy\n      started = false\n      this.isDown = false\n      if (this.up) this.up(e)\n      this.sweeping = false\n    }\n  })\n  return canvas\n}\n\nif (String.prototype.endsWith === undefined) {\n  String.prototype.endsWith = function (suffix) {\n    return this.indexOf(suffix, this.length - suffix.length) !== -1\n  }\n}\n\nif (typeof Object.assign !== 'function') {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, 'assign', {\n    value: function assign(target, varArgs) {\n      // .length of function is 2\n      'use strict'\n      if (target === null || target === undefined) {\n        throw new TypeError('Cannot convert undefined or null to object')\n      }\n\n      var to = Object(target)\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index]\n\n        if (nextSource !== null && nextSource !== undefined) {\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey]\n            }\n          }\n        }\n      }\n      return to\n    },\n    writable: true,\n    configurable: true\n  })\n}\n"},367:function(n,t){n.exports="function Prop(type, getFunc, setFunc) {\n  this.type = type\n  this.get = getFunc\n  this.set = setFunc\n  this.editable = true\n  this.ignoreInBuilder = false\n  this.options = null\n  this.isColor = false\n  this.step = undefined\n}\n\nProp.prototype.disableEdit = function () {\n  this.editable = false\n  return this\n}\n\nProp.prototype.setIgnoreInBuilder = function () {\n  this.ignoreInBuilder = true\n  return this\n}\n\nProp.prototype.setOptions = function (opts) {\n  this.options = opts\n  return this\n}\n\nProp.prototype.setIsColor = function () {\n  this.isColor = true\n  return this\n}\n\nProp.prototype.setStep = function (step) {\n  this.step = step\n  return this\n}\n\nfunction Position(x, y, w, h) {\n  this.x = x\n  this.y = y\n  this.w = w\n  this.h = h\n}\n\nPosition.prototype.equals = function (o) {\n  return this.x === o.x && this.y === o.y && this.w === o.w && this.h === o.h\n}\n\nfunction Widget(grid, uuid, element) {\n  this.x = 0\n  this.y = 0\n  this.w = 2\n  this.h = 2\n  this.tab = 0\n\n  this.grid = grid\n  this.uuid = uuid\n  this.el = element\n  this.eventListener = null\n  this.extraCss = {}\n\n  this.el.style.position = 'absolute'\n  this.el.classList.add('grid-widget')\n}\n\nWidget.SUBCLASSES = []\n\nWidget.prototype.MIN_LIBRARY_VERSION = 0x040000\n\nWidget.prototype.PROPERTIES = {\n  id: new Prop(String).setIgnoreInBuilder(),\n  x: new Prop(Number).setIgnoreInBuilder(),\n  y: new Prop(Number).setIgnoreInBuilder(),\n  w: new Prop(Number).setIgnoreInBuilder(),\n  h: new Prop(Number).setIgnoreInBuilder(),\n  tab: new Prop(Number).setIgnoreInBuilder(),\n  css: new Prop(\n    Object,\n    function () {\n      return this.extraCss\n    },\n    function (val) {\n      for (var k in this.extraCss) {\n        if (!this.extraCss.hasOwnProperty(k)) continue\n        this.el.style.removeProperty(k)\n      }\n      this.extraCss = {}\n      for (var k in val) {\n        if (!val.hasOwnProperty(k)) continue\n        this.el.style.setProperty(k, val[k], 'important')\n        this.extraCss[k] = val[k]\n      }\n    }\n  )\n}\n\nWidget.createSubclass = function (cls, properties, events) {\n  cls.prototype = Object.create(Widget.prototype)\n  Object.defineProperty(cls.prototype, 'constructor', {\n    value: cls,\n    enumerable: false,\n    writable: true\n  })\n\n  Widget.SUBCLASSES.push(cls)\n\n  cls.prototype.PROPERTIES = {}\n  Object.assign(cls.prototype.PROPERTIES, Widget.prototype.PROPERTIES)\n  if (properties) {\n    Object.assign(cls.prototype.PROPERTIES, properties)\n  }\n\n  cls.prototype.EVENTS = {}\n  if (events) {\n    Object.assign(cls.prototype.EVENTS, events)\n  }\n}\n\nWidget.wrapCanvas = function (canvas) {\n  var wrapper = document.createElement('div')\n  canvas.style.width = '100%'\n  canvas.style.height = '100%'\n  wrapper.appendChild(canvas)\n  return wrapper\n}\n\nWidget.prototype.applyState = function (state) {\n  var proto = Object.getPrototypeOf(this)\n  var pos = false\n  for (var k in state) {\n    var v = state[k]\n\n    if(k === \"p\") {\n      if(typeof v === \"string\") {\n        v = parseInt(v, 16);\n      }\n\n      this.x = (v & 0xFF)/10;\n      this.y = ((v >> 8) & 0xFF)/10;\n      this.w = ((v >> 16) & 0xFF)/10;\n      this.h = ((v >> 24) & 0xFF)/10;\n      pos = true\n      continue;\n    }\n\n    if (!state.hasOwnProperty(k) || !proto.PROPERTIES.hasOwnProperty(k)) {\n      continue\n    }\n\n    var prop = proto.PROPERTIES[k]\n    if (prop.set === undefined) {\n      this[k] = prop.type(v)\n    } else {\n      prop.set.call(this, v)\n    }\n\n    if (k.length === 1 && 'xywh'.indexOf(k) !== -1) {\n      pos = true\n    }\n  }\n\n  if (pos) {\n    this.updatePosition()\n  }\n}\n\nWidget.prototype.setEventListener = function (listener) {\n  this.eventListener = listener\n}\n\nWidget.prototype.updatePosition = function () {\n  var pos = this.grid.calculatePxPos(this)\n  this.el.style.left = '' + pos.x + 'px'\n  this.el.style.top = '' + pos.y + 'px'\n  this.el.style.width = '' + pos.w + 'px'\n  this.el.style.height = '' + pos.h + 'px'\n}\n\nWidget.prototype.update = function (diffMs) {}\n\nWidget.prototype.sendEvent = function (name, extra, mustArrive, callback) {\n  if (this.eventListener === null) return\n  this.eventListener(\n    this,\n    name,\n    extra ? extra : {},\n    mustArrive !== false,\n    callback\n  )\n}\n\nWidget.prototype.pos = function () {\n  return new Position(this.x, this.y, this.w, this.h)\n}\n\nWidget.prototype.getState = function () {\n  var res = {}\n  var proto = Object.getPrototypeOf(this)\n  for (var key in proto.PROPERTIES) {\n    if (!proto.PROPERTIES.hasOwnProperty(key)) continue\n\n    var prop = proto.PROPERTIES[key]\n    if (prop.get === undefined) {\n      res[key] = prop.type(this[key])\n    } else {\n      res[key] = prop.get.call(this)\n    }\n  }\n  return res\n}\n\nfunction UpdateLimiter(msDelay, sendCountBeforeDelay) {\n  this.msDelay = msDelay\n  this.sendCountBeforeDelay = sendCountBeforeDelay\n\n  this.sent = 0\n  this.lastDelayedSend = 0\n}\n\nUpdateLimiter.prototype.isLimited = function(forceUpdateNow) {\n  if(!forceUpdateNow) {\n    if(this.sent < this.sendCountBeforeDelay) {\n      ++this.sent;\n      return false\n    }\n\n    var now = Date.now()\n    if(now - this.lastDelayedSend > this.msDelay) {\n      this.lastDelayedSend = now\n      return false\n    }\n    return true\n  } else if(this.sent !== 0) {\n    this.sent = 0\n    return false\n  }\n}\n"},368:function(n,t){n.exports="function Grid(manager, elementId, data) {\n  this.manager = manager\n\n  this.el = document.getElementById(elementId)\n  this.widgets = []\n\n  this.canvas = document.createElement('canvas')\n  this.canvas.style.position = 'absolute'\n  this.canvas.style.top = '0px'\n  this.el.appendChild(this.canvas)\n\n  this.tabs = []\n  this.currentTabIdx = 0\n  this.setTabCount(1)\n  this.setCurrentTab(0)\n\n  window.addEventListener('resize', this.onResize.bind(this))\n\n  var focusedInput = null\n  this.el.addEventListener(\n    'touchstart',\n    function (ev) {\n      if (ev.target.tagName === 'INPUT') {\n        ev.target.focus()\n        focusedInput = ev.target\n      } else if (focusedInput !== null) {\n        focusedInput.blur()\n        focusedInput = null\n      }\n    }.bind(this)\n  )\n\n  this.isSplit = 0\n  this.offsetX = 0\n  this.offsetY = 0\n  this.scaleX = 1\n  this.scaleY = 1\n\n  this.reset(data)\n}\n\nGrid.prototype.setCurrentTab = function (idx) {\n  this.tabs[this.currentTabIdx].style.display = 'none'\n  this.tabs[idx].style.display = 'block'\n  this.currentTabIdx = idx\n  for (w of this.widgets) {\n    if (w instanceof Switcher)\n      w.value = idx\n    w.applyState(w.getState())\n  }\n}\n\nGrid.prototype.moveToTab = function (widget, tab, oldTab) {\n  widget.tab = oldTab\n  this.removeWidget(widget)\n  widget.tab = tab\n  this.addWidgetConstructed(widget)\n}\n\nGrid.prototype.setTabCount = function (count) {\n  if (this.tabs.length === count || count <= 0) {\n    return\n  }\n\n  if (this.tabs.length < count) {\n    for (var i = this.tabs.length; i < count; ++i) {\n      var t = document.createElement('div')\n      t.style.width = '100%'\n      t.style.height = '100%'\n      t.style.display = 'none'\n      this.el.appendChild(t) \n      this.tabs[i] = t\n    }\n  } else {\n    while (this.tabs.length > count) {\n      var t = this.tabs.pop()\n      this.el.removeChild(t)\n    }\n    if (this.currentTabIdx >= this.tabs.length) {\n      this.currentTabIdx = this.tabs.length - 1\n    }\n  }\n}\n\nGrid.prototype.reset = function (data) {\n  this.COLS = data.cols\n  this.ROWS = data.rows\n  this.enableSplitting = !!data.enableSplitting\n  this.drawGrid = !!data.drawGrid\n\n  this.clear()\n\n  for (var i = 0; i < data.widgets.length; ++i) {\n    var w = data.widgets[i]\n    this.addWidget(w.uuid, w.type, w['state'])\n  }\n\n  this.onResize()\n}\n\nGrid.prototype.onResize = function () {\n  var w = this.el.clientWidth\n  var h = this.el.clientHeight\n\n  this.offsetX = 0\n  this.offsetY = 0\n\n  this.isSplit = this.shouldSplitGrid(w, h)\n  if (!this.isSplit) {\n    if (w > h) {\n      this.offsetX = (w - h) / 2\n      w = h\n    }\n\n    this.scaleX = w / this.COLS\n    this.scaleY = h / this.ROWS\n\n    this.canvas.style.width = '' + this.el.clientWidth + 'px'\n    this.canvas.style.height = '' + this.el.clientHeight + 'px'\n    this.canvas.width = this.el.clientWidth + 2\n    this.canvas.height = this.el.clientHeight + 2\n\n    this.drawGridDots(this.COLS, this.ROWS)\n  } else {\n    this.scaleX = w / (this.COLS * 2)\n    this.scaleY = h / Math.round(this.ROWS / 2)\n\n    this.canvas.style.width = '' + this.el.clientWidth + 'px'\n    this.canvas.style.height = '' + this.el.clientHeight + 'px'\n    this.canvas.width = this.el.clientWidth + 2\n    this.canvas.height = this.el.clientHeight + 2\n\n    this.drawGridDots(this.COLS * 2, this.ROWS / 2)\n  }\n\n  var len = this.widgets.length\n  for (var i = 0; i < len; ++i) {\n    this.widgets[i].updatePosition()\n  }\n}\n\nGrid.prototype.calculatePxPos = function (w) {\n  var res = {\n    w: w.w * this.scaleX,\n    h: w.h * this.scaleY\n  }\n\n  if (!this.isSplit) {\n    res.x = this.offsetX + w.x * this.scaleX\n    res.y = this.offsetY + w.y * this.scaleY\n  } else {\n    var centerY = Math.round(this.ROWS / 2)\n    if (w.y >= centerY) {\n      res.x = w.x + this.COLS\n      res.y = w.y - centerY\n    } else {\n      res.x = w.x\n      res.y = w.y\n    }\n    res.x *= this.scaleX\n    res.y *= this.scaleY\n  }\n\n  return res\n}\n\nGrid.prototype.shouldSplitGrid = function (w, h) {\n  if (this.enableSplitting !== true || w <= h) return false\n\n  var centerY = this.ROWS / 2\n\n  var len = this.widgets.length\n  for (var i = 0; i < len; ++i) {\n    var w = this.widgets[i]\n    if (w.y < centerY && w.y + w.h > centerY) return false\n  }\n  return true\n}\n\nGrid.prototype.drawGridDots = function (cols, rows) {\n  if (!this.drawGrid) return\n\n  var ctx = this.canvas.getContext('2d')\n\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n  ctx.fillStyle = '#777'\n\n  for (var x = 0; x <= cols; ++x) {\n    for (var y = 0; y <= rows; ++y) {\n      ctx.beginPath()\n      ctx.arc(\n        this.offsetX + x * this.scaleX + 1,\n        this.offsetY + y * this.scaleY + 1,\n        1,\n        0,\n        Math.PI * 2,\n        false\n      )\n      ctx.fill()\n    }\n  }\n}\n\nGrid.prototype.addWidget = function (uuid, typeName, extra) {\n  try {\n    var w = new window[typeName](this, uuid)\n  } catch (e) {\n    console.log(typeName, e)\n    return\n  }\n  w.applyState(extra)\n  this.addWidgetConstructed(w)\n}\n\nGrid.prototype.addWidgetConstructed = function (widget) {\n  widget.updatePosition()\n  widget.setEventListener(this.onWidgetEvent.bind(this))\n\n  \n  if (this.tabs.length <= widget.tab) \n    this.setTabCount(widget.tab + 1)\n  this.tabs[widget.tab].appendChild(widget.el)\n  this.widgets.push(widget)\n}\n\nGrid.prototype.removeWidget = function (widget) {\n  var idx = this.widgets.indexOf(widget)\n  if (idx === -1) return false\n\n  this.tabs[widget.tab].removeChild(widget.el)\n  this.widgets.splice(idx, 1)\n  return true\n}\n\nGrid.prototype.clear = function () {\n  var len = this.widgets.length\n  for (var i = 0; i < len; ++i) {\n    var w = this.widgets[i]\n    this.tabs[w.tab].removeChild(w.el)\n  }\n  this.widgets.length = 0\n  this.setTabCount(1)\n}\n\nGrid.prototype.onWidgetEvent = function (w, name, extra, mustArrive, callback) {\n  //console.log(\"Event from \" + w.uuid + \": \" + name + \" \" + JSON.stringify(extra));\n\n  if (this.manager === null) return\n\n  var data = {\n    id: w.uuid,\n    ev: name\n  }\n\n  if (extra !== undefined && extra !== null) {\n    data['st'] = extra\n  }\n\n  if (mustArrive !== false) {\n    this.manager.sendMustArrive('_gev', data, false, callback)\n  } else {\n    this.manager.send('_gev', data)\n  }\n}\n\nGrid.prototype.update = function (diffMs) {\n  var len = this.widgets.length\n  for (var i = 0; i < len; ++i) {\n    var w = this.widgets[i]\n    w.update(diffMs)\n  }\n}\n\nGrid.prototype.onMessageState = function (data) {\n  var len = this.widgets.length\n  for (var i = 0; i < len; ++i) {\n    var w = this.widgets[i]\n    var state = data[w.uuid.toString()]\n    if (state !== undefined) {\n      w.applyState(state)\n    }\n  }\n}\n\nGrid.prototype.getWidgetByUuid = function (uuid) {\n  var len = this.widgets.length\n  for (var i = 0; i < len; ++i) {\n    var w = this.widgets[i]\n    if (w.uuid === uuid) {\n      return w\n    }\n  }\n  return null\n}\n\nGrid.prototype.getWidgetAtPos = function (x, y) {\n  var len = this.widgets.length\n  for (var i = len - 1; i >= 0; --i) {\n    var w = this.widgets[i]\n    var r = w.el.getBoundingClientRect()\n    if (r.left <= x && r.right >= x && r.top <= y && r.bottom >= y) {\n      return w\n    }\n  }\n  return null\n}\n\nGrid.prototype.roundToPrecision = function (x, precision) {\n  var y = +x + (precision === undefined ? 0.5 : precision / 2)\n  return y - (y % (precision === undefined ? 1 : +precision))\n}\n\nGrid.prototype.pxPosToCoordinates = function (x, y) {\n  var rect = this.el.getBoundingClientRect()\n  x -= rect.left\n  y -= rect.top\n\n  x = this.roundToPrecision(x / this.scaleX, 0.5)\n  y = this.roundToPrecision(y / this.scaleY, 0.5)\n  return {\n    x: x,\n    y: y\n  }\n}\n\nGrid.prototype.tryMoveWidget = function (w, x, y) {\n  var coords = this.pxPosToCoordinates(x, y)\n  x = coords.x\n  y = coords.y\n  if (x == w.x && y == w.y) return false\n\n  w.x = Math.min(this.COLS - 1, Math.max(-w.w + 1, x))\n  w.y = Math.min(this.ROWS - 1, Math.max(-w.h + 1, y))\n  w.updatePosition()\n  return true\n}\n\nGrid.prototype.tryScaleWidget = function (widget, r, b) {\n  var coords = this.pxPosToCoordinates(r, b)\n\n  var w = coords.x - widget.x\n  var h = coords.y - widget.y\n\n  if (w == widget.w && h == widget.h) return false\n\n  widget.w = Math.min(this.COLS, Math.max(0.5, w))\n  widget.h = Math.min(this.ROWS, Math.max(0.5, h))\n  widget.updatePosition()\n  return true\n}\n"},369:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(370))},370:function(n,t){n.exports="function clampAng(val) {\n  val = val % (Math.PI * 2)\n  if (val < -Math.PI) val += Math.PI * 2\n  else if (val > Math.PI) val -= Math.PI * 2\n  return val\n}\n\nfunction deg(rad) {\n  return rad * (180.0 / Math.PI)\n}\n\nfunction Bone(info, color, prev) {\n  this.length = info.len\n  this.color = color\n\n  this.x = 0\n  this.y = 0\n  this.angle = info.angle\n  if (prev === null) {\n    this.relAngle = this.angle\n  } else {\n    this.relAngle = clampAng(this.angle - prev.angle)\n  }\n\n  this.relMin = info.rmin\n  this.relMax = info.rmax\n  this.absMin = info.amin\n  this.absMax = info.amax\n  this.baseMin = info.bmin\n  this.baseMax = info.bmax\n}\n\nBone.prototype.toInfo = function () {\n  return {\n    len: this.length,\n    angle: this.angle,\n    rmin: this.relMin,\n    rmax: this.relMax,\n    amin: this.absMin,\n    amax: this.absMax,\n    bmin: this.baseMin,\n    bmax: this.baseMax\n  }\n}\n\nBone.prototype.updatePos = function (prevBone, unit) {\n  this.angle = this.relAngle\n  if (prevBone) {\n    this.angle = clampAng(prevBone.angle + this.angle)\n  }\n\n  this.x = Math.cos(this.angle) * this.length * unit\n  this.y = Math.sin(this.angle) * this.length * unit\n\n  if (prevBone) {\n    this.x += prevBone.x\n    this.y += prevBone.y\n  }\n}\n\nfunction Animation(arm) {\n  this.arm = arm\n  this.keyframes = []\n  this.curFrame = -1\n  this.lastTick = null\n  this.cmdSent = true\n}\n\nAnimation.prototype.addFrame = function (x, y, durationMs) {\n  this.keyframes.push({\n    x: x,\n    y: y,\n    duration: durationMs,\n    current: 0\n  })\n}\n\nAnimation.prototype.start = function () {\n  this.lastTick = performance.now()\n  this.nextFrame()\n  requestAnimationFrame(this.update.bind(this))\n}\n\nAnimation.prototype.nextFrame = function () {\n  this.curFrame += 1\n  if (this.curFrame >= this.keyframes.length) return false\n  var f = this.keyframes[this.curFrame]\n\n  var b = this.arm.bones[this.arm.bones.length - 1]\n  f.start_x = b.x / this.arm.unit\n  f.start_y = b.y / this.arm.unit\n\n  this.arm.pointer.x = f.x * this.arm.unit + this.arm.origin.x\n  this.arm.pointer.y = f.y * this.arm.unit + this.arm.origin.y\n  this.arm.run()\n\n  this.cmdSent = false\n\n  this.arm.sendEvent(\n    'pos',\n    { armX: f.x, armY: f.y },\n    true,\n    function () {\n      this.cmdSent = true\n      requestAnimationFrame(this.update.bind(this))\n    }.bind(this)\n  )\n\n  return true\n}\n\nAnimation.prototype.update = function () {\n  var now = performance.now()\n  var diff = now - this.lastTick\n  this.lastTick = now\n\n  if (!this.cmdSent) return\n\n  if (this.curFrame >= this.keyframes.length) {\n    this.arm.animation = null\n    return\n  }\n\n  var f = this.keyframes[this.curFrame]\n  f.current += diff\n\n  var progress = f.current / f.duration\n  if (progress >= 1.0) progress = 1.0\n\n  if (progress >= 1.0 && !this.nextFrame()) {\n    this.arm.animation = null\n    return\n  }\n\n  requestAnimationFrame(this.update.bind(this))\n}\n\nfunction Arm(grid, uuid) {\n  var el = document.createElement('canvas')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 12\n  this.h = 9\n\n  this.BODY_HEIGHT = 0\n  this.BODY_RADIUS = 0\n  this.ARM_BASE_HEIGHT = 0\n  this.TOUCH_TARGET_SIZE = 4\n  this.ARM_TOTAL_LEN = 0\n\n  this.bones = []\n\n  this.BUTTON_TEXTS = ['RETRACT', 'EXTEND', 'GRAB']\n  this.buttons = []\n  for (var i = 0; i < this.BUTTON_TEXTS.length; ++i) {\n    this.buttons.push({\n      text: this.BUTTON_TEXTS[i],\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0,\n      blink: false\n    })\n  }\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.resize.bind(this)\n\n  this.unit = 1\n  this.origin = { x: 0, y: 0 }\n  this.pointer = this.canvas.pointer\n\n  this.touched = false\n  this.touchedButton = null\n  this.animation = null\n\n  this.pointer.down = function () {\n    this.touchedButton = this.getTouchedButton()\n    if (this.touchedButton === null && this.animation === null) {\n      this.run()\n      this.touched = true\n    }\n  }.bind(this)\n  this.pointer.up = function () {\n    if (this.touchedButton !== null) {\n      if (this.getTouchedButton() === this.touchedButton) {\n        this.touchedButton.blink = true\n        this.draw()\n        setTimeout(\n          function (btn) {\n            btn.blink = false\n            this.draw()\n          }.bind(this, this.touchedButton),\n          100\n        )\n        this.handleButton(this.touchedButton.text.toUpperCase())\n      }\n      this.touchedButton = null\n    } else {\n      this.touched = false\n      requestAnimationFrame(this.run.bind(this))\n    }\n  }.bind(this)\n  this.pointer.move = function () {\n    if (this.touched) requestAnimationFrame(this.run.bind(this))\n  }.bind(this)\n\n  this.resize()\n  this.updateAngles(true)\n\n  this.touched = false\n}\n\nWidget.createSubclass(Arm, {\n  info: new Prop(\n    Object,\n    function () {\n      var bones = []\n      for (var i = 0; i < this.bones.length; ++i)\n        bones.push(this.bones[i].toInfo())\n      return {\n        radius: this.BODY_RADIUS,\n        height: this.BODY_HEIGHT,\n        off_y: this.ARM_BASE_HEIGHT,\n        bones: bones\n      }\n    },\n    function (info) {\n      this.BODY_RADIUS = info.radius\n      this.BODY_HEIGHT = info.height\n      this.ARM_BASE_HEIGHT = info.off_y\n      this.ARM_TOTAL_LEN = 0\n\n      this.bones = []\n      var colors = ['blue', 'orange', 'green', 'red', 'brown']\n      var prev = null\n      for (var i = 0; i < info.bones.length; ++i) {\n        this.ARM_TOTAL_LEN += info.bones[i].len\n        prev = new Bone(info.bones[i], colors[i % colors.length], prev)\n        this.bones.push(prev)\n      }\n    }\n  ).disableEdit()\n},\n{\n  \"grab\": \"onGrab\",\n  \"pos\": \"onPositionChanged\"\n})\n\nArm.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n\n  this.resize()\n  this.updateAngles(true)\n}\n\nArm.prototype.shouldSend = function () {\n  return this.bones !== null && this.animation === null\n}\n\nArm.prototype.resize = function () {\n  this.unit =\n    Math.min(this.canvas.width * 0.6, this.canvas.height * 0.8) /\n    this.ARM_TOTAL_LEN\n\n  var w = this.canvas.width / this.buttons.length\n  var h = this.canvas.height * 0.15\n  var y = this.canvas.height - h\n  var x = 0\n  for (var i = 0; i < this.buttons.length; ++i) {\n    var b = this.buttons[i]\n    b.x = x\n    b.y = y\n    b.w = w\n    b.h = h\n    x += w\n  }\n\n  this.origin.x = this.BODY_RADIUS * this.unit\n  this.origin.y =\n    y - this.BODY_HEIGHT * 1.3 * this.unit - this.unit * this.ARM_BASE_HEIGHT\n\n  this.draw()\n}\n\nArm.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nArm.prototype.getTouchedButton = function () {\n  var x = this.pointer.x\n  var y = this.pointer.y\n  for (var i = 0; i < this.buttons.length; ++i) {\n    var b = this.buttons[i]\n    if (x > b.x && x < b.x + b.w && y > b.y && y < b.y + b.h) return b\n  }\n  return null\n}\n\nArm.prototype.handleButton = function (text) {\n  switch (text) {\n    case 'RETRACT':\n      if (this.animation !== null) break\n      this.animation = new Animation(this)\n      this.animation.addFrame(145, -35, 600)\n      this.animation.addFrame(35, 19, 300)\n      this.animation.start()\n      break\n    case 'EXTEND':\n      if (this.animation !== null) break\n      this.animation = new Animation(this)\n      this.animation.addFrame(145, -35, 500)\n      this.animation.addFrame(200, 18, 200)\n      this.animation.addFrame(140, 79, 300)\n      this.animation.start()\n      break\n    case 'GRAB':\n      this.sendEvent('grab')\n      break\n  }\n}\n\nArm.prototype.drawSegment = function (seg, color) {\n  this.drawLine(seg.sx, seg.sy, seg.ex, seg.ey, color, 3, 6)\n}\n\nArm.prototype.drawPointer = function (src, dst, color) {\n  var ctx = this.canvas.ctx\n  ctx.beginPath()\n  ctx.strokeStyle = color\n  ctx.fillStyle = color\n  ctx.lineWidth = 2\n  ctx.setLineDash([6, 3])\n  ctx.moveTo(src.x, src.y)\n  //  ctx.lineTo(dst.x, dst.y);\n  ctx.moveTo(dst.x + this.TOUCH_TARGET_SIZE * 2, dst.y)\n  ctx.arc(dst.x, dst.y, this.TOUCH_TARGET_SIZE * 2, 0, 2 * Math.PI)\n  ctx.stroke()\n  ctx.setLineDash([])\n}\n\nArm.prototype.drawCircleDashed = function (x, y, radius, color) {\n  var ctx = this.canvas.ctx\n  ctx.beginPath()\n  ctx.strokeStyle = color\n  ctx.lineWidth = 2\n  ctx.setLineDash([6, 3])\n  ctx.moveTo(x, y)\n  ctx.arc(x, y, radius, 0, 2 * Math.PI)\n  ctx.stroke()\n  ctx.setLineDash([])\n}\n\nArm.prototype.drawTouchTarget = function (x, y) {\n  var ctx = this.canvas.ctx\n  ctx.beginPath()\n  ctx.fillStyle = 'red'\n  ctx.moveTo(x, y)\n  ctx.arc(x, y, this.TOUCH_TARGET_SIZE, 0, 2 * Math.PI)\n  ctx.fill()\n}\n\nArm.prototype.drawLine = function (x0, y0, x1, y1, color, width, dotRadius) {\n  var ctx = this.canvas.ctx\n  ctx.beginPath()\n  ctx.strokeStyle = color\n  ctx.fillStyle = color\n  ctx.lineWidth = width\n  ctx.moveTo(x0, y0)\n  ctx.lineTo(x1, y1)\n  ctx.stroke()\n  if (dotRadius !== undefined) {\n    ctx.moveTo(x0, y0)\n    ctx.arc(x0, y0, dotRadius, 0, 2 * Math.PI)\n    ctx.moveTo(x1, y1)\n    ctx.arc(x1, y1, dotRadius, 0, 2 * Math.PI)\n    ctx.fill()\n  }\n}\n\nArm.prototype.updateAngles = function (updateAbsAngles) {\n  var prev = null\n  for (var i = 0; i < this.bones.length; ++i) {\n    if (updateAbsAngles === true) this.bones[i].updatePos(prev, this.unit)\n    prev = this.bones[i]\n  }\n}\n\nArm.prototype.run = function () {\n  var dx = this.pointer.x - this.origin.x\n  var dy = this.pointer.y - this.origin.y\n  for (var i = 0; i < 10; ++i) {\n    var res = this.solve(dx, dy)\n    if (res == 0) {\n      continue\n    } else if (res == -1) {\n      //console.log(\"FAILED\");\n    }\n    break\n  }\n\n  this.updateAngles(true)\n  this.draw()\n}\n\nArm.prototype.getTargetPos = function () {\n  if (this.bones === null || this.bones.length === 0) return null\n\n  var end = this.bones[this.bones.length - 1]\n  return {\n    x: end.x / this.unit,\n    y: end.y / this.unit\n  }\n}\n\nArm.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n\n  ctx.fillStyle = '#ffffff'\n  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n\n  ctx.font = '12px monospace'\n  ctx.fillStyle = 'black'\n  var dx = (this.pointer.x - this.origin.x) / this.unit\n  var dy = (this.pointer.y - this.origin.y) / this.unit\n  ctx.fillText(dx.toFixed(1), 20, 12)\n  ctx.fillText(dy.toFixed(1), 20, 24)\n\n  var tgt = this.getTargetPos()\n  if (tgt !== null) {\n    ctx.fillText(tgt.x.toFixed(1), 80, 12)\n    ctx.fillText(tgt.y.toFixed(1), 80, 24)\n  }\n\n  ctx.save()\n  ctx.translate(this.origin.x, this.origin.y)\n  var w = this.unit * this.BODY_RADIUS * 2\n  var h = this.unit * this.BODY_HEIGHT\n\n  ctx.fillStyle = '#C8A165'\n  ctx.fillRect(-w / 2, this.ARM_BASE_HEIGHT * this.unit, w, h)\n\n  for (var i = 0; i < this.bones.length; ++i) {\n    var s = this.bones[i]\n\n    ctx.save()\n    ctx.rotate(s.relAngle)\n    this.drawLine(0, 0, s.length * this.unit, 0, s.color, 3, 6)\n\n    ctx.translate(s.length * this.unit, 0)\n  }\n\n  for (var i = 0; i < this.bones.length; ++i) {\n    ctx.restore()\n  }\n\n  /*ctx.font = '18px monospace';\n    ctx.fillStyle = \"black\"\n    var y = this.BODY_HEIGHT*this.unit;\n    for(var i = 0; i < this.bones.length; ++i) {\n        var b = this.bones[i];\n\n        ctx.fillText((b.angle >= 0 ? \" \" : \"\") + b.angle.toFixed(2), -100, y);\n        ctx.fillText((b.angle >= 0 ? \" \" : \"\") + deg(b.angle).toFixed(2), 0, y);\n        ctx.fillText((b.relAngle >= 0 ? \" \" : \"\") + b.relAngle.toFixed(2), 100, y);\n        ctx.fillText((b.relAngle >= 0 ? \" \" : \"\") + deg(b.relAngle).toFixed(2), 200, y);\n\n        var relBase = this.bones[i].angle - this.bones[0].angle;\n        ctx.fillText((relBase >= 0 ? \" \" : \"\") + relBase.toFixed(2), -350, y);\n        y += 20;\n    }*/\n\n  ctx.restore()\n\n  ctx.strokeStyle = 'blue'\n  ctx.lineWidth = 3\n  ctx.textAlign = 'center'\n  ctx.textBaseline = 'middle'\n  ctx.font = this.buttons[0].h / 3 + 'px monospace'\n  ctx.fillStyle = 'black'\n  for (var i = 0; i < this.buttons.length; ++i) {\n    var b = this.buttons[i]\n    if (b.blink) {\n      ctx.fillStyle = 'red'\n      ctx.fillRect(b.x, b.y, b.w, b.h)\n      ctx.fillStyle = 'black'\n    }\n    ctx.strokeRect(b.x, b.y, b.w, b.h)\n    ctx.fillText(b.text, b.x + b.w / 2, b.y + b.h / 2)\n  }\n\n  this.drawPointer(this.origin, this.pointer, 'red')\n}\n\nBone.prototype.rotate = function (prev, rotAng) {\n  var newRelAng = clampAng(this.relAngle + rotAng)\n  var _min = this.relMin\n  var _max = this.relMax\n  if (newRelAng < _min) {\n    newRelAng = _min\n  } else if (newRelAng > _max) {\n    newRelAng = _max\n  }\n\n  var res = clampAng(newRelAng - this.relAngle)\n  this.relAngle = newRelAng\n  return res\n}\n\nArm.prototype.fixBodyCollision = function () {\n  var base = this.bones[0]\n  var endBone = this.bones[this.bones.length - 1]\n  base.relAngle = Math.min(Math.max(base.relAngle, base.relMin), base.relMax)\n  this.updateAngles(true)\n\n  while (this.isInBody(endBone.x, endBone.y)) {\n    var newang = clampAng(base.relAngle - 0.01)\n    if (newang > base.relMax || newang < base.relMin) return\n    base.relAngle = newang\n    this.updateAngles(true)\n  }\n}\n\nArm.prototype.isInBody = function (x, y) {\n  return (\n    Math.abs(x) <= this.BODY_RADIUS * this.unit &&\n    y >= this.ARM_BASE_HEIGHT * this.unit\n  )\n}\n\nArm.prototype.solve = function (targetX, targetY) {\n  if (this.bones === null || this.bones.length === 0) return\n\n  var prev = null\n  for (var i = 0; i < this.bones.length; ++i) {\n    this.bones[i].updatePos(prev, this.unit)\n    prev = this.bones[i]\n  }\n\n  // Limit under-robot positions\n  if (targetX < this.unit * this.BODY_RADIUS) {\n    if (targetY > this.unit * this.ARM_BASE_HEIGHT)\n      targetY = this.unit * this.ARM_BASE_HEIGHT\n  } else {\n    if (targetY > this.unit * (this.ARM_BASE_HEIGHT + this.BODY_HEIGHT))\n      targetY = this.unit * (this.ARM_BASE_HEIGHT + this.BODY_HEIGHT)\n  }\n\n  if (targetX < 5 * this.unit) {\n    targetY = 0\n    targetX = 0\n  }\n\n  var endX = prev.x\n  var endY = prev.y\n\n  var modifiedBones = false\n  for (var i = this.bones.length - 1; i >= 0; --i) {\n    var b = this.bones[i]\n\n    var bx = 0\n    var by = 0\n    if (i > 0) {\n      bx = this.bones[i - 1].x\n      by = this.bones[i - 1].y\n    }\n\n    // Get the vector from the current bone to the end effector position.\n    var curToEndX = endX - bx\n    var curToEndY = endY - by\n    var curToEndMag = Math.sqrt(curToEndX * curToEndX + curToEndY * curToEndY)\n\n    // Get the vector from the current bone to the target position.\n    var curToTargetX = targetX - bx\n    var curToTargetY = targetY - by\n    var curToTargetMag = Math.sqrt(\n      curToTargetX * curToTargetX + curToTargetY * curToTargetY\n    )\n\n    // Get rotation to place the end effector on the line from the current\n    // joint position to the target postion.\n    var cosRotAng\n    var sinRotAng\n    var endTargetMag = curToEndMag * curToTargetMag\n\n    if (endTargetMag <= 0.0001) {\n      cosRotAng = 1\n      sinRotAng = 0\n    } else {\n      cosRotAng =\n        (curToEndX * curToTargetX + curToEndY * curToTargetY) / endTargetMag\n      sinRotAng =\n        (curToEndX * curToTargetY - curToEndY * curToTargetX) / endTargetMag\n    }\n\n    // Clamp the cosine into range when computing the angle (might be out of range\n    // due to floating point error).\n    var rotAng = Math.acos(Math.max(-1, Math.min(1, cosRotAng)))\n    if (sinRotAng < 0.0) rotAng = -rotAng\n\n    // Rotate the current bone in local space (this value is output to the user)\n    // b.angle = overflow(b.angle + rotAng, Math.PI*2);\n    rotAng = this.rotateArm(this.bones, i, rotAng)\n    cosRotAng = Math.cos(rotAng)\n    sinRotAng = Math.sin(rotAng)\n\n    // Rotate the end effector position.\n    endX = bx + cosRotAng * curToEndX - sinRotAng * curToEndY\n    endY = by + sinRotAng * curToEndX + cosRotAng * curToEndY\n\n    // Check for termination\n    var endToTargetX = targetX - endX\n    var endToTargetY = targetY - endY\n    if (endToTargetX * endToTargetX + endToTargetY * endToTargetY <= 10) {\n      this.fixBodyCollision()\n      // We found a valid solution.\n      return 1\n    }\n\n    // Track if the arc length that we moved the end effector was\n    // a nontrivial distance.\n    if (!modifiedBones && Math.abs(rotAng) * curToEndMag > 0.000001)\n      modifiedBones = true\n  }\n\n  this.fixBodyCollision()\n\n  if (modifiedBones) return 0\n  return -1\n}\n\nArm.prototype.rotateArm = function (bones, idx, rotAng) {\n  var me = bones[idx]\n\n  var base = bones[0]\n\n  var newRelAng = clampAng(me.relAngle + rotAng)\n  var _min = me.relMin\n  var _max = me.relMax\n  if (newRelAng < _min) {\n    newRelAng = _min\n  } else if (newRelAng > _max) {\n    newRelAng = _max\n  }\n\n  var x = 0\n  var y = 0\n  var prevAng = 0\n  for (var i = 0; i < bones.length; ++i) {\n    var b = bones[i]\n    var angle = b.relAngle\n    if (idx == i) {\n      angle = newRelAng\n    }\n    angle = clampAng(prevAng + angle)\n\n    // arm helper-sticks collision with the bottom of the servo stand\n    if (i == idx) {\n      if (angle < b.absMin) {\n        angle = b.absMin\n        newRelAng = clampAng(angle - prevAng)\n      } else if (angle > b.absMax) {\n        angle = b.absMax\n        newRelAng = clampAng(angle - prevAng)\n      }\n    }\n\n    var nx = x + Math.cos(angle) * b.length * this.unit\n    var ny = y + Math.sin(angle) * b.length * this.unit\n\n    if (i > 0) {\n      var diff = angle - base.angle\n      if (diff < b.baseMin) {\n        base.angle = clampAng(angle - b.baseMin)\n      } else if (diff > b.baseMax) {\n        base.angle = clampAng(angle - b.baseMax)\n      }\n    }\n\n    x = nx\n    y = ny\n    prevAng = angle\n  }\n\n  var res = clampAng(newRelAng - me.relAngle)\n  me.relAngle = newRelAng\n  return res\n}\n\nArm.prototype.update = function (diffMs) {\n  if (!this.shouldSend()) return\n  var pos = this.getTargetPos()\n  if (pos !== null)\n    this.sendEvent(\n      'pos',\n      {\n        armX: pos.x,\n        armY: pos.y\n      },\n      false\n    )\n}\n"},371:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(372))},372:function(n,t){n.exports="function Bar(grid, uuid) {\n  this.color = '#008000'\n  this.fontSize = 16\n  this.min = 0\n  this.max = 100\n  this.value = 0\n  this.showValue = false\n\n  var el = document.createElement('canvas')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 1\n  this.h = 3\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n}\n\nWidget.createSubclass(Bar, {\n  color: new Prop(String).setIsColor(),\n  fontSize: new Prop(Number),\n  min: new Prop(Number),\n  max: new Prop(Number),\n  value: new Prop(Number),\n  showValue: new Prop(Boolean)\n})\n\nBar.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nBar.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nBar.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  ctx.save()\n\n  var w = this.canvas.width\n  var h = this.canvas.height\n  if (this.h > this.w) {\n    w = this.canvas.height\n    h = this.canvas.width\n    ctx.rotate(-Math.PI / 2)\n    ctx.translate(-w, 0)\n  }\n\n  ctx.fillStyle = this.color\n  ctx.strokeStyle = this.color\n  ctx.lineWidth = 2\n\n  var padding = 4\n  ctx.strokeRect(padding, padding, w - padding * 2, h - padding * 2)\n\n  var frac = (this.value - this.min) / (this.max - this.min)\n  ctx.fillRect(\n    padding * 2,\n    padding * 2,\n    (w - padding * 4) * frac,\n    h - padding * 4\n  )\n\n  if (this.showValue) {\n    ctx.translate(w / 2, h / 2)\n    if (this.h > this.w) {\n      ctx.rotate(Math.PI / 2)\n    }\n    ctx.lineWidth = 3\n    ctx.strokeStyle = 'white'\n    ctx.fillStyle = 'black'\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = this.fontSize + 'px sans-serif'\n    ctx.strokeText('' + this.value, 0, 0)\n    ctx.fillText('' + this.value, 0, 0)\n  }\n\n  ctx.restore()\n}\n"},373:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(374))},374:function(n,t){n.exports="function Button(grid, uuid) {\n  var el = document.createElement('button')\n  el.style.display = 'flex'\n\n  this.span = document.createElement('span')\n  el.appendChild(this.span)\n  this.span.innerText = 'Button'\n\n  Widget.call(this, grid, uuid, el)\n\n  this.w = 3\n  this.h = 1\n\n  this.pressed = false\n\n  this.el.style.justifyContent = this.align = 'center'\n  this.el.style.alignItems = this.valign = 'center'\n\n  this.fontSize = 12\n  this.span.style.fontSize = this.fontSize + 'pt'\n\n  this.color = '#000000'\n  this.background = ''\n\n  if (!('ontouchstart' in document.documentElement)) {\n    el.addEventListener(\n      'mousedown',\n      function (ev) {\n        this.sendEvent('press', { pressed: true })\n        this.pressed = true\n      }.bind(this)\n    )\n\n    document.addEventListener(\n      'mouseup',\n      function (ev) {\n        if (!this.pressed) return\n        this.sendEvent('release', { pressed: false })\n        this.pressed = false\n      }.bind(this)\n    )\n  } else {\n    this.el.addEventListener(\n      'touchstart',\n      function (ev) {        \n        if (this.pressed) return\n        this.pressed = true\n        this.sendEvent('press', { pressed: true })\n      }.bind(this)\n    )\n    this.el.addEventListener(\n      'touchend',\n      function (ev) {\n        if (!this.pressed) return\n        this.pressed = false\n        this.sendEvent('release', { pressed: false })\n      }.bind(this)\n    )\n  }\n}\n\nWidget.createSubclass(Button, {\n  text: new Prop(\n    String,\n    function () {\n      return this.span.innerText\n    },\n    function (val) {\n      this.span.innerText = val\n    }\n  ),\n  fontSize: new Prop(Number, undefined, function (val) {\n    this.fontSize = val\n    this.span.style.fontSize = val + 'pt'\n  }),\n  color: new Prop(String, undefined, function (val) {\n    this.color = val\n    this.el.style.color = val\n  }).setIsColor(),\n  background: new Prop(String, undefined, function (val) {\n    this.background = val\n    this.el.style.backgroundColor = val\n  }).setIsColor(),\n  align: new Prop(String, undefined, function (val) {\n    this.align = val\n    this.el.style.justifyContent = val\n  }).setOptions(['flex-start', 'center', 'flex-end']),\n  valign: new Prop(String, undefined, function (val) {\n    this.valign = val\n    this.el.style.alignItems = val\n  }).setOptions(['flex-start', 'center', 'flex-end']),\n  disabled: new Prop(\n    Boolean,\n    function () {\n      return this.el.disabled\n    },\n    function (val) {\n      this.el.disabled = !!val\n    }\n  )\n},\n{\n  \"press\": \"onPress\",\n  \"release\": \"onRelease\"\n})\n"},375:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(376))},376:function(n,t){n.exports='function Camera(grid, uuid) {\n  var el = document.createElement(\'canvas\')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 4\n  this.h = 4\n  this.rotation = 90\n  this.clip = false\n  this.frame = null\n  this.badStatus = false\n  this.tags = []\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n\n  if(window[\'IN_RB_GRID_DESIGNER\'] !== true) {\n    this.scheduleFrameDownload();\n  }\n}\n\nWidget.createSubclass(Camera, {\n  rotation: new Prop(Number),\n  clip: new Prop(Boolean),\n  tags: new Prop(Array, function() {\n    return this.tags\n  }, function(tags) {\n    this.tags = tags\n  }).disableEdit(),\n})\n\nCamera.prototype.MIN_LIBRARY_VERSION = 0x041000\n\nCamera.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nCamera.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nCamera.prototype.scheduleFrameDownload = function() {\n  requestAnimationFrame(this.downloadFrame.bind(this))\n}\n\nCamera.prototype.downloadFrame = function() {\n  this.badStatus = false\n\n  var req = new XMLHttpRequest();\n  req.responseType = \'blob\';\n  req.timeout = 500\n\n  req.addEventListener("load", function() {\n    if(req.status !== 200) {\n      this.badStatus = true\n      this.draw()\n      setTimeout(this.scheduleFrameDownload.bind(this), req.status === 503 ? 500 : 10000)\n      return;\n    }\n\n    createImageBitmap(req.response)\n      .then(function(bitmap) {\n        if(this.frame !== null) {\n          this.frame.close()\n        }\n        this.frame = bitmap\n        this.draw()\n      }.bind(this))\n  }.bind(this));\n\n  req.addEventListener("loadend", function() {\n    if(!this.badStatus) {\n      this.scheduleFrameDownload()\n    }\n  }.bind(this))\n  \n  req.open("GET", "/extra/camera.jpg");\n  req.send();\n}\n\nCamera.prototype.draw = function() {\n  var ctx = this.canvas.ctx\n  var cw = this.canvas.width\n  var ch = this.canvas.height\n\n  var fw, fh\n  if(this.frame !== null) {\n    fw = this.frame.width\n    fh = this.frame.height\n  } else {\n    fw = 4\n    fh = 3\n  }\n\n  ctx.clearRect(0, 0, cw, ch)\n  ctx.save();\n  ctx.translate(cw/2,ch/2);\n\n  // swap dimensions on rotation\n  if(this.rotation%180 >= 45 && this.rotation%180 < 135) {\n    var t = cw\n    cw = ch\n    ch = t\n  }\n\n  var ratioCanvas = cw / ch\n  var rationFrame = fw / fh\n\n  var scaledW, scaledH\n  if(!this.clip) {\n    if(rationFrame > ratioCanvas) {\n      scaledW = cw\n      scaledH = cw / rationFrame\n    } else {\n      scaledH = ch\n      scaledW = ch * rationFrame\n    }\n  } else {\n    if(rationFrame > ratioCanvas) {\n      scaledH = ch\n      scaledW = ch * rationFrame\n    } else {\n      scaledW = cw\n      scaledH = cw / rationFrame\n    }\n  }\n\n  if(this.frame !== null) {\n    ctx.rotate(this.rotation*Math.PI/180);\n    ctx.drawImage(this.frame, -scaledW/2, -scaledH/2, scaledW, scaledH)\n  } else {\n    ctx.font = "16px serif";\n    ctx.textAlign = "center"\n    if(this.badStatus) {\n      ctx.fillText("No camera present.", 0, 0, Math.min(cw, ch))\n    } else {\n      ctx.fillText("No frame yet.", 0, 0, Math.min(cw, ch))\n    }\n\n    ctx.rotate(this.rotation*Math.PI/180);\n    ctx.strokeStyle = "black";\n    ctx.strokeRect(-scaledW/2, -scaledH/2, scaledW, scaledH)\n  }\n\n  var scale = scaledW / fw\n\n  ctx.font = "40px sans-serif";\n  ctx.fillStyle = "red";\n  ctx.textAlign = "center"\n  ctx.strokeStyle = "red";\n  ctx.lineWidth = 3;\n\n  for(var i = 0; i < this.tags.length; ++i) {\n    var t = this.tags[i];\n\n    ctx.beginPath();\n    ctx.moveTo(t.c00*scale - scaledW/2, t.c01*scale - scaledH/2)\n    ctx.lineTo(t.c10*scale - scaledW/2, t.c11*scale - scaledH/2)\n    ctx.lineTo(t.c20*scale - scaledW/2, t.c21*scale - scaledH/2)\n    ctx.lineTo(t.c30*scale - scaledW/2, t.c31*scale - scaledH/2)\n    ctx.lineTo(t.c00*scale - scaledW/2, t.c01*scale - scaledH/2)\n    ctx.stroke();\n\n    var textX = ((t.c00 + t.c20)/2)*scale - scaledW/2\n    var textY = ((t.c01 + t.c21)/2)*scale - scaledH/2\n    ctx.save()\n    ctx.translate(textX, textY)\n    ctx.rotate(this.rotation*Math.PI/180*-1)\n    ctx.fillText(t.id.toString(), 0, 0)\n    ctx.restore()\n  }\n  \n  ctx.restore()\n}\n'},377:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(378))},378:function(n,t){n.exports="function Checkbox(grid, uuid) {\n  this.color = '#000000'\n  this.checked = false\n  this.text = 'CheckBox'\n  this.fontSize = 14\n\n  var el = document.createElement('canvas')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 4\n  this.h = 1\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n  this.canvas.pointer.up = function () {\n    this.checked = !this.checked\n    this.draw()\n    this.sendEvent('checked', { checked: this.checked })\n  }.bind(this)\n}\n\nWidget.createSubclass(Checkbox, {\n  fontSize: new Prop(Number),\n  checked: new Prop(Boolean),\n  color: new Prop(String).setIsColor(),\n  text: new Prop(String)\n},\n{\n  \"checked\": \"onChanged\",\n})\n\nCheckbox.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nCheckbox.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nCheckbox.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  ctx.save()\n\n  var w = this.canvas.width\n  var h = this.canvas.height\n  if (this.h > this.w) {\n    w = this.canvas.height\n    h = this.canvas.width\n    ctx.rotate(Math.PI / 2)\n    ctx.translate(0, -h)\n  }\n\n  var side = Math.min(w, h)\n  var padding = side * 0.1\n  side -= padding * 2\n\n  if (this.text !== '') {\n    var textX = side + padding * 3\n    ctx.textBaseline = 'middle'\n    ctx.font = this.fontSize + 'px sans-serif'\n    ctx.fillText(this.text, textX, h / 2, w - textX)\n    ctx.translate(padding + side / 2, padding + side / 2)\n  } else {\n    ctx.translate(w / 2, h / 2)\n  }\n\n  ctx.fillStyle = this.color\n  ctx.strokeStyle = this.color\n  ctx.lineWidth = 2\n\n  ctx.strokeRect(-side / 2, -side / 2, side, side)\n  if (this.checked) {\n    ctx.fillRect(\n      -side / 2 + padding,\n      -side / 2 + padding,\n      side - padding * 2,\n      side - padding * 2\n    )\n  }\n\n  ctx.restore()\n}\n"},379:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(380))},380:function(n,t){n.exports="function Circle(grid, uuid) {\n  this.color = '#008000'\n  this.fontSize = 16\n  this.min = 0\n  this.max = 360\n  this.valueStart = 0\n  this.value = 200\n  this.showValue = true\n  this.lineWidth = 10\n\n  var el = document.createElement('canvas')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 3\n  this.h = 3\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n}\n\nWidget.createSubclass(Circle, {\n  color: new Prop(String).setIsColor(),\n  fontSize: new Prop(Number),\n  min: new Prop(Number),\n  max: new Prop(Number),\n  lineWidth: new Prop(Number),\n  valueStart: new Prop(Number),\n  value: new Prop(Number),\n  showValue: new Prop(Boolean)\n})\n\nCircle.prototype.MIN_LIBRARY_VERSION = 0x040700\n\nCircle.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nCircle.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nCircle.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  ctx.save()\n\n  var padding = 4 + this.lineWidth / 2\n  var w = this.canvas.width\n  var h = this.canvas.height\n  var arcRadius = Math.max(1, Math.min(w, h) / 2 - padding)\n\n  if (!w || !h) {\n    return\n  }\n\n  var valueStartClipped = Math.max(this.valueStart, this.min)\n  var angleStart =\n    ((valueStartClipped - this.min) / (this.max - this.min)) * Math.PI * 2\n  var angleEnd = ((this.value - this.min) / (this.max - this.min)) * Math.PI * 2\n  // Let's start on top\n  angleStart -= Math.PI / 2\n  angleEnd -= Math.PI / 2\n\n  ctx.lineWidth = this.lineWidth\n\n  ctx.beginPath()\n  ctx.globalAlpha = 0.1\n  ctx.strokeStyle = this.color\n  ctx.arc(w / 2, h / 2, arcRadius, 0, Math.PI * 2)\n  ctx.stroke()\n\n  ctx.globalAlpha = 1\n  ctx.beginPath()\n  ctx.strokeStyle = this.color\n  ctx.arc(w / 2, h / 2, arcRadius, angleStart, angleEnd)\n  ctx.stroke()\n\n  if (this.showValue) {\n    ctx.translate(w / 2, h / 2)\n    ctx.lineWidth = 3\n    ctx.strokeStyle = 'white'\n    ctx.fillStyle = 'black'\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = this.fontSize + 'px sans-serif'\n    ctx.strokeText('' + this.value, 0, 0)\n    ctx.fillText('' + this.value, 0, 0)\n  }\n\n  ctx.restore()\n}\n"},381:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(382))},382:function(n,t){n.exports="function Input(grid, uuid) {\n  var el = document.createElement('div')\n  el.style.padding = '2px'\n\n  this.input = document.createElement('input')\n  this.input.type = 'text'\n  this.input.style.all = 'revert'\n  this.input.style.width = '100%'\n  this.input.style.height = '100%'\n  this.input.style.borderWidth = '2px'\n  this.input.style.boxSizing = 'border-box'\n  this.input.style.borderColor = this.color = '#cccccc'\n  el.appendChild(this.input)\n\n  Widget.call(this, grid, uuid, el)\n\n  this.w = 4\n  this.h = 1\n\n  this.input.addEventListener(\n    'change',\n    function () {\n      this.sendEvent('changed', { text: this.input.value })\n    }.bind(this)\n  )\n\n  if ('ontouchstart' in document.documentElement) {\n    this.input.addEventListener(\n      'focus',\n      function () {\n        if (this.input.parentElement === this.el) {\n          this.el.removeChild(this.input)\n          this.el.parentElement.appendChild(this.input)\n          this.input.style.boxShadow = '5px 5px 5px black'\n          this.input.style.fontSize = '150%'\n          this.input.style.position = 'absolute'\n          this.input.style.top = '15px'\n          this.input.style.left = '50%'\n          this.input.style.marginLeft = '-45%'\n          this.input.style.width = '90%'\n          this.input.style.height = '2em'\n          this.input.focus()\n        }\n      }.bind(this)\n    )\n\n    this.input.addEventListener(\n      'blur',\n      function () {\n        if (this.input.parentElement !== this.el) {\n          this.el.parentElement.removeChild(this.input)\n          this.el.appendChild(this.input)\n          this.input.style.width = '100%'\n          this.input.style.height = '100%'\n          this.input.style.boxShadow = null\n          this.input.style.position = null\n          this.input.style.top = null\n          this.input.style.left = null\n          this.input.style.marginLeft = null\n          this.input.style.fontSize = null\n        }\n      }.bind(this)\n    )\n  }\n}\n\nWidget.createSubclass(Input, {\n  text: new Prop(\n    String,\n    function () {\n      return this.input.value\n    },\n    function (val) {\n      this.input.value = val\n    }\n  ),\n  color: new Prop(String, undefined, function (val) {\n    this.color = val\n    this.input.style.borderColor = val\n  }).setIsColor(),\n  type: new Prop(\n    String,\n    function () {\n      return this.input.type\n    },\n    function (val) {\n      this.input.type = val\n    }\n  ).setOptions(['text', 'number', 'password']),\n  disabled: new Prop(\n    Boolean,\n    function () {\n      return this.input.disabled\n    },\n    function (val) {\n      this.input.disabled = !!val\n    }\n  )\n},\n{\n  \"changed\": \"onChanged\",\n})\n"},383:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(384))},384:function(n,t){n.exports="function Joystick(grid, uuid) {\n  var el = document.createElement('div')\n\n  this.color = '#FF0000'\n  this.text = ''\n  this.keys = ''\n\n  Widget.call(this, grid, uuid, el)\n\n  this.w = 4\n  this.h = 4\n\n  this.radius = 0\n  this.valX = 0\n  this.valY = 0\n  this.buttonClickHandler = null\n  this.touchStart = null\n  this.pressedKeys = {}\n  this.manager = null\n  this.limiter = new UpdateLimiter(5000, 32)\n\n  document.addEventListener('keydown', this.onKeyDown.bind(this))\n  document.addEventListener('keyup', this.onKeyUp.bind(this))\n}\n\nWidget.createSubclass(Joystick, {\n  color: new Prop(String).setIsColor(),\n  keys: new Prop(String),\n  text: new Prop(String)\n},\n{\n  \"click\": \"onClick\",\n  \"pos\": \"onPositionChanged\",\n})\n\nJoystick.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n\n  if (this.manager !== null) this.createNippleJs()\n}\n\nJoystick.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.createNippleJs.bind(this), 0)\n}\n\nJoystick.prototype.createNippleJs = function () {\n  if (this.manager !== null) {\n    this.manager.destroy()\n  }\n\n  this.radius = Math.min(this.el.clientHeight, this.el.clientWidth) / 2\n\n  this.manager = nipplejs.create({\n    zone: this.el,\n    mode: 'static',\n    color: this.color,\n    size: this.radius * 2,\n    position: {\n      top: '50%',\n      left: '50%'\n    },\n    restOpacity: 0.9,\n    fadeTime: 0\n  })\n\n  this.joy = this.manager.get(this.manager.ids[0])\n\n  if (this.text !== '') {\n    var nipple = this.joy.ui.front\n    nipple.innerHTML = this.text\n    nipple.style.fontWeight = 'bold'\n    nipple.style.fontFamily = 'Arial, Helvetica, sans-serif'\n    nipple.style.color = 'white'\n    nipple.style.textAlign = 'center'\n    nipple.style.verticalAlign = 'middle'\n    nipple.style.lineHeight = nipple.style.height\n  }\n\n  this.manager.on(\n    'start',\n    function (event, data) {\n      this.touchStart = Date.now()\n      this.valX = 0\n      this.valY = 0\n    }.bind(this)\n  )\n\n  this.manager.on(\n    'move',\n    function (event, data) {\n      var dist = (data.distance / this.radius) * 32767\n      this.valX = (Math.cos(data.angle.radian) * dist) | 0\n      this.valY = (Math.sin(data.angle.radian) * dist) | 0\n    }.bind(this)\n  )\n\n  this.manager.on(\n    'end',\n    function (event, data) {\n      var diff = Date.now() - this.touchStart\n      if (\n        diff < 150 &&\n        Math.abs(this.valX) < 8000 &&\n        Math.abs(this.valY) < 8000\n      ) {\n        this.sendEvent('click')\n      }\n\n      this.valX = 0\n      this.valY = 0\n    }.bind(this)\n  )\n}\n\nJoystick.prototype.onKeyDown = function (ev) {\n  if (this.keys === '') return\n  var idx = this.keys.indexOf(ev.key)\n  if (idx === -1) return\n  if (idx === 4) {\n    this.sendEvent('click')\n  }\n  this.pressedKeys[idx] = true\n  this.updateNippleFront()\n}\n\nJoystick.prototype.onKeyUp = function (ev) {\n  if (this.keys === '') return\n  var idx = this.keys.indexOf(ev.key)\n  if (idx === -1) return\n  this.pressedKeys[idx] = false\n  this.updateNippleFront()\n}\n\nJoystick.prototype.updateNippleFront = function () {\n  var p = this.pressedKeys\n  var left = 0\n  var top = 0\n  if (p[0] === true) top -= 1\n  if (p[2] === true) top += 1\n  if (p[1] === true) left -= 1\n  if (p[3] === true) left += 1\n\n  this.valX = left * 28000\n  this.valY = top * -28000\n\n  var fr = this.joy.ui.front\n  fr.style.left = left * this.radius + 'px'\n  fr.style.top = top * this.radius + 'px'\n}\n\nJoystick.prototype.update = function () {\n  if(this.limiter.isLimited(this.valX !== 0 || this.valY !== 0)) {\n    return\n  }\n\n  this.sendEvent(\n    'pos',\n    {\n      jx: this.valX,\n      jy: this.valY\n    },\n    false\n  )\n}\n"},385:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(386))},386:function(n,t){n.exports="function Led(grid, uuid) {\n  this.color = '#FF0000'\n  this.on = false\n\n  var el = document.createElement('canvas')\n\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 1\n  this.h = 1\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n}\n\nWidget.createSubclass(Led, {\n  color: new Prop(String).setIsColor(),\n  on: new Prop(Boolean)\n})\n\nLed.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nLed.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nLed.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  var x = this.canvas.width / 2\n  var y = this.canvas.height / 2\n  var radius = Math.min(this.canvas.height, this.canvas.width) / 2\n\n  ctx.save()\n  if (this.on) {\n    ctx.fillStyle = this.color\n    ctx.shadowColor = this.color\n    ctx.shadowBlur = radius * 0.5\n    ctx.lineWidth = 1\n    ctx.beginPath()\n    ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2, false)\n    ctx.fill()\n  } else {\n    ctx.lineWidth = radius * 0.1\n    ctx.strokeStyle = this.color\n\n    ctx.beginPath()\n    ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2, false)\n    ctx.stroke()\n  }\n  ctx.restore()\n}\n"},387:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(388))},388:function(n,t){n.exports="function Orientation(grid, uuid) {\n  this.color = '#FF0000'\n\n  if (\n    window['RbGravitySensor'] === undefined &&\n    window['IN_RB_GRID_DESIGNER'] !== true\n  ) {\n    this.enabled = false\n    this.canvas = null\n\n    var el = document.createElement('span')\n    el.innerText =\n      'Orientation sensor requires the Android RBController app, version >= 1.9.'\n    Widget.call(this, grid, uuid, el)\n  } else {\n    this.enabled = window['IN_RB_GRID_DESIGNER'] !== true\n\n    var el = document.createElement('canvas')\n    Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n    this.canvas = ge1doot.canvas(el)\n    this.canvas.resize = this.draw.bind(this)\n\n    if (this.enabled) {\n      RbGravitySensor.start()\n    } else {\n      this.demoRollDelta = 0.02\n      requestAnimationFrame(this.doGridDesignerDemo.bind(this))\n    }\n  }\n\n  this.w = 1\n  this.h = 1\n\n  this.yaw = 0.0\n  this.pitch = 0.0\n  this.roll = 0.0\n}\nWidget.createSubclass(Orientation, {\n  color: new Prop(String).setIsColor()\n},\n{\n  \"pos\": \"onPositionChanged\",\n})\n\nOrientation.prototype.MIN_LIBRARY_VERSION = 0x040200\n\nOrientation.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nOrientation.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  if (this.canvas !== null) setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nOrientation.prototype.doGridDesignerDemo = function () {\n  if (!this.canvas.elem.isConnected) {\n    return\n  }\n  this.roll += this.demoRollDelta\n  if (this.roll > 1 || this.roll < -1) {\n    this.demoRollDelta *= -1\n  }\n  this.draw()\n  requestAnimationFrame(this.doGridDesignerDemo.bind(this))\n}\n\nOrientation.prototype.draw = function () {\n  if (this.canvas === null) return\n\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  var radius = Math.min(this.canvas.height, this.canvas.width) / 4\n  var centerX = this.canvas.width / 2\n  var centerY = this.canvas.height / 2\n\n  var y = centerY + this.yaw * (this.canvas.height / 2)\n  var x = centerX - this.roll * (this.canvas.height / 2)\n\n  ctx.save()\n  ctx.fillStyle = this.color\n  ctx.shadowColor = this.color\n  ctx.shadowBlur = radius * 0.5\n  ctx.lineWidth = 1\n  ctx.beginPath()\n  ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2, false)\n  ctx.fill()\n  ctx.restore()\n\n  ctx.strokeColor = '#000'\n  ctx.beginPath()\n  ctx.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2, false)\n  ctx.stroke()\n}\n\nOrientation.prototype.update = function () {\n  if (this.enabled === false) {\n    return\n  }\n\n  this.yaw = RbGravitySensor.getYaw()\n  this.pitch = RbGravitySensor.getPitch()\n  this.roll = RbGravitySensor.getRoll()\n\n  this.sendEvent(\n    'pos',\n    {\n      oy: this.yaw,\n      op: this.pitch,\n      or: this.roll\n    },\n    false\n  )\n  this.draw()\n}\n"},389:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(390))},390:function(n,t){n.exports="function Select(grid, uuid) {\n  var el = document.createElement('select')\n  el.style.display = 'flex'\n\n  Widget.call(this, grid, uuid, el)\n\n  this.w = 3\n  this.h = 1\n\n  this.el.selectedIndex = this.selectedIndex = 0\n  this.options = \"None\"\n  this.el.add(new Option(\"None\", \"0\"))\n\n  this.color = '#000000'\n  this.background = ''\n\n  this.el.addEventListener(\n    'change',\n    function () {\n      this.sendEvent('changed', { value: this.selectedIndex })\n    }.bind(this)\n  )\n}\n\nWidget.createSubclass(Select, {\n  color: new Prop(String, undefined, function (val) {\n    this.color = val\n    this.el.style.color = val\n  }).setIsColor(),\n  background: new Prop(String, undefined, function (val) {\n    this.background = val\n    this.el.style.backgroundColor = val\n  }).setIsColor(),\n  disabled: new Prop(\n    Boolean,\n    function () {\n      return this.el.disabled\n    },\n    function (val) {\n      this.el.disabled = !!val\n    }\n  ),\n  options: new Prop(\n    String,\n    function () {\n      const opts = Array(this.el.length)\n\n      for (let i = 0; i < this.el.length; i++) {\n        opts[this.el[i].value] = this.el[i].text\n      }\n\n      return opts.join(',')\n    },\n\n    function (val) {\n      if (!val) val = \"None\"\n      while (this.el.length > 0) {\n        this.el.remove(0)\n      }\n\n      const newOpts = val.split(\",\")\n      for (let index = 0; index < newOpts.length; index++) {\n        this.el.add(new Option(newOpts[index], index))\n      }\n\n      this.options = val\n    }\n  ),\n  selectedIndex: new Prop(\n    Number,\n    function () {\n      return this.el.selectedIndex\n    },\n    function (val) {\n      this.el.selectedIndex = val\n    }\n  ),\n},\n{\n  \"changed\": \"onChanged\",\n})\n\nSelect.prototype.MIN_LIBRARY_VERSION = 0x040800\n"},391:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(392))},392:function(n,t){n.exports="function Slider(grid, uuid) {\n  this.PADDING_FRAC = 0.03\n\n  this.color = '#008000'\n  this.fontSize = 16\n  this.min = 0\n  this.max = 100\n  this.value = 0\n  this.showValue = true\n  this.precision = 1\n\n  var el = document.createElement('canvas')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 4\n  this.h = 1\n  this.touched = false\n  this.sendValueTimer = null\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n\n  var pointer = this.canvas.pointer\n\n  pointer.down = function () {\n    this.touched = true\n    this.movePos(pointer)\n  }.bind(this)\n\n  pointer.up = function () {\n    this.touched = false\n  }.bind(this)\n\n  pointer.move = function () {\n    if (this.touched) {\n      this.movePos(pointer)\n    }\n  }.bind(this)\n}\n\nWidget.createSubclass(Slider, {\n  color: new Prop(String).setIsColor(),\n  fontSize: new Prop(Number),\n  min: new Prop(Number),\n  max: new Prop(Number),\n  value: new Prop(Number),\n  precision: new Prop(Number),\n  showValue: new Prop(Boolean)\n},\n{\n  \"changed\": \"onChanged\",\n})\n\nSlider.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nSlider.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nSlider.prototype.roundToPrecision = function (x, precision) {\n  var y = +x + (precision === undefined ? 0.5 : precision / 2)\n  return y - (y % (precision === undefined ? 1 : +precision))\n}\n\nSlider.prototype.movePos = function (pointer) {\n  var x = pointer.x\n  var w = this.canvas.width\n  if (this.h > this.w) {\n    x = this.canvas.height - pointer.y\n    w = this.canvas.height\n  }\n\n  var padding = w * this.PADDING_FRAC\n  x = Math.min(w - padding, x)\n  x = Math.max(0, x - padding)\n  w -= padding * 2\n\n  var frac = x / w\n  this.value = this.roundToPrecision(\n    this.min + (this.max - this.min) * frac,\n    this.precision\n  )\n  this.sendValue()\n  this.draw()\n}\n\nSlider.prototype.sendValue = function () {\n  if (this.sendValueTimer !== null) return\n\n  this.sendValueTimer = setTimeout(\n    function () {\n      this.sendValueTimer = null\n      this.sendEvent('changed', { value: this.value })\n    }.bind(this),\n    100\n  )\n}\n\nSlider.prototype.formatValue = function (value, precision) {\n  var pStr = '' + precision\n  var idx = pStr.indexOf('.')\n  var decimals = 0\n  if (idx !== -1) {\n    decimals = pStr.length - (idx + 1)\n  }\n  return value.toFixed(decimals)\n}\n\nSlider.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  ctx.save()\n\n  var w = this.canvas.width\n  var h = this.canvas.height\n  if (this.h > this.w) {\n    w = this.canvas.height\n    h = this.canvas.width\n    ctx.rotate(-Math.PI / 2)\n    ctx.translate(-w, 0)\n  }\n\n  ctx.fillStyle = this.color\n  ctx.strokeStyle = this.color\n  ctx.lineWidth = 2\n\n  var padding = w * this.PADDING_FRAC\n\n  var guideH = Math.max(2, h * 0.05)\n  ctx.fillRect(padding, h / 2 - guideH / 2, w - padding * 2, guideH)\n\n  var frac = (this.value - this.min) / (this.max - this.min)\n  guideH *= 2\n  ctx.fillRect(padding + (w - padding * 2) * frac - guideH / 2, 0, guideH, h)\n\n  if (this.showValue) {\n    ctx.translate(w / 2, h / 2)\n    if (this.h > this.w) {\n      ctx.rotate(Math.PI / 2)\n    }\n    ctx.lineWidth = 3\n    ctx.strokeStyle = 'white'\n    ctx.fillStyle = 'black'\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = this.fontSize + 'px sans-serif'\n    var txt = this.formatValue(this.value, this.precision)\n    ctx.strokeText(txt, 0, 0)\n    ctx.fillText(txt, 0, 0)\n  }\n\n  ctx.restore()\n}\n"},393:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(394))},394:function(n,t){n.exports="function SpinEdit(grid, uuid) {\n  this.color = '#000000'\n  this.fontSize = 14\n  this.value = 0\n  this.step = 1\n  this.precision = 1\n\n  var el = document.createElement('canvas')\n  Widget.call(this, grid, uuid, Widget.wrapCanvas(el))\n\n  this.w = 4\n  this.h = 1\n\n  this.canvas = ge1doot.canvas(el)\n  this.canvas.resize = this.draw.bind(this)\n  this.canvas.pointer.up = function () {\n    const part = this.canvas.width / 4\n    if (this.canvas.pointer.x < part) {\n      this.value -= this.step\n    } else if (this.canvas.pointer.x > part * 3) {\n      this.value += this.step\n    } else {\n      return\n    }\n\n    this.sendEvent('changed', { value: this.value })\n    this.draw()\n  }.bind(this)\n}\n\nWidget.createSubclass(SpinEdit, {\n  fontSize: new Prop(Number),\n  color: new Prop(String).setIsColor(),\n  value: new Prop(Number),\n  step: new Prop(Number),\n  precision: new Prop(Number)\n},\n{\n  \"changed\": \"onChanged\",\n})\n\nSpinEdit.prototype.MIN_LIBRARY_VERSION = 0x040600\n\nSpinEdit.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nSpinEdit.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nSpinEdit.prototype.formatValue = function (value, precision) {\n  var pStr = '' + precision\n  var idx = pStr.indexOf('.')\n  var decimals = 0\n  if (idx !== -1) {\n    decimals = pStr.length - (idx + 1)\n  }\n  return value.toFixed(decimals)\n}\n\nSpinEdit.prototype.draw = function () {\n  var ctx = this.canvas.ctx\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  const part = this.canvas.width / 4\n  const padding = part * 0.2\n\n  ctx.lineWidth = Math.max(2, this.canvas.height * 0.05)\n  ctx.fillStyle = this.color\n  ctx.strokeStyle = this.color\n\n  // minus\n  ctx.strokeRect(padding, this.canvas.height / 2, part - padding * 2, 1)\n\n  // plus\n  ctx.save()\n  ctx.translate(part * 3, 0)\n  const minusW = part - padding * 2\n  ctx.strokeRect(padding, this.canvas.height / 2, minusW, 1)\n  ctx.strokeRect(part / 2, this.canvas.height / 2 - minusW / 2, 1, minusW)\n  ctx.restore()\n\n  // text\n  ctx.save()\n  ctx.textAlign = 'center'\n  ctx.textBaseline = 'middle'\n  ctx.font = this.fontSize + 'px sans-serif'\n  ctx.fillText(\n    this.formatValue(this.value, this.precision),\n    this.canvas.width / 2,\n    this.canvas.height / 2\n  )\n  ctx.restore()\n}\n"},395:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(396))},396:function(n,t){n.exports="function Switcher(grid, uuid) {\n  this.color = '#000000'\n  this.fontSize = 14\n  this.value = 0\n  this.__switcher = true\n  this.grid = grid\n\n  var el = document.createElement('div')\n  Widget.call(this, grid, uuid, el)\n\n  var canvas = document.createElement('canvas')\n  canvas.style.width = '100%'\n  canvas.style.height = '100%'\n\n  this.input = document.createElement('input')\n  this.input.type = 'text'\n  this.input.style.all = 'revert'\n  this.input.style.height = '100%'\n  this.input.style.borderWidth = '2px'\n  this.input.style.boxSizing = 'border-box'\n  this.input.style.borderColor = '#cccccc'\n  this.input.style.position = 'absolute'\n\n  el.appendChild(canvas)\n  el.appendChild(this.input)\n\n  this.w = 4\n  this.h = 1\n\n  this.canvas = ge1doot.canvas(canvas)\n  this.canvas.resize = this.draw.bind(this)\n  this.canvas.pointer.up = function () {\n    var bounds = this.el.getBoundingClientRect()\n    const width = bounds.width\n    const height = bounds.height\n    const part = width >= 3 * height\n      ? height\n      : this.canvas.width / 4\n    const inputWidth = width >= 3 * height\n      ? (width - 2 * height)\n      : width / 2\n    if (this.canvas.pointer.x < part) {\n      this.value -= 1\n      if (this.value < this.min)\n        this.value = this.min\n    } else if (this.canvas.pointer.x > part + inputWidth) {\n      this.value += 1\n      if (this.value > this.max)\n        this.value = this.max\n    } else {\n      return\n    }\n\n    this.sendEvent('changed', { value: this.value })\n    this.draw()\n  }.bind(this)\n\n  this.input.addEventListener(\n    'change',\n    function () {\n      const val = parseInt(this.input.value, 10)\n      if (val < this.min)\n        val = this.min\n      else if (val > min(this.max, this.grid.tabs.length))\n        val = min(this.max, this.grid.tabs.length)\n      this.value = val\n      this.draw()\n      this.sendEvent('changed', { value: this.value })\n    }.bind(this)\n  )\n}\n\nWidget.createSubclass(Switcher, {\n  fontSize: new Prop(Number),\n  color: new Prop(String).setIsColor(),\n  value: new Prop(Number),\n  min: new Prop(Number),\n  max: new Prop(Number)\n},\n{\n  \"changed\": \"onChanged\",\n})\n\nSwitcher.prototype.MIN_LIBRARY_VERSION = 0x041000\n\nSwitcher.prototype.applyState = function (state) {\n  Widget.prototype.applyState.call(this, state)\n  this.draw()\n}\n\nSwitcher.prototype.updatePosition = function (x, y, scaleX, scaleY) {\n  Widget.prototype.updatePosition.call(this, x, y, scaleX, scaleY)\n\n  setTimeout(this.canvas.setSize.bind(this.canvas), 0)\n}\n\nSwitcher.prototype.formatValue = function (value, precision) {\n  var pStr = '' + precision\n  var idx = pStr.indexOf('.')\n  var decimals = 0\n  if (idx !== -1) {\n    decimals = pStr.length - (idx + 1)\n  }\n  return value.toFixed(decimals)\n}\n\nSwitcher.prototype.draw = function () {\n  var bounds = this.el.getBoundingClientRect()\n  const width = bounds.width\n  const height = bounds.height\n\n  var ctx = this.canvas.ctx\n\n  const inputWidth = width >= 3 * height\n    ? (width - 2 * height)\n    : width / 2\n\n  const part = width >= 3 * height\n    ? height\n    : this.canvas.width / 4\n\n  let padding = part * 0.2\n\n  this.input.style.width = inputWidth + 'px'\n  this.input.style.left = part + 'px'\n  this.input.value = this.value.toString()\n\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n  ctx.lineWidth = Math.max(2, this.canvas.height * 0.05)\n  ctx.fillStyle = this.color\n  ctx.strokeStyle = this.color\n\n  // left\n  ctx.save()\n  ctx.translate(padding, this.canvas.height / 2)\n  ctx.beginPath()\n  ctx.moveTo(0, 0)\n  ctx.lineTo(part - padding * 2, this.canvas.height / 4)\n  ctx.moveTo(0, 0)\n  ctx.lineTo(part - padding * 2, - this.canvas.height / 4)\n  ctx.stroke()\n  ctx.restore()\n\n  // right\n  ctx.save()\n  ctx.translate(this.canvas.width - padding, this.canvas.height / 2)\n  ctx.beginPath()\n  ctx.moveTo(padding * 2 - part, this.canvas.height / 4)\n  ctx.lineTo(0, 0)\n  ctx.moveTo(padding * 2 - part, - this.canvas.height / 4)\n  ctx.lineTo(0, 0)\n  ctx.stroke()\n  ctx.restore()\n}\n"},397:function(n,t,e){e(2),e(3),e(4),e(5),e(227)(e(398))},398:function(n,t){n.exports="function Text(grid, uuid) {\n  var el = document.createElement('div')\n  el.style.display = 'flex'\n\n  this.span = document.createElement('span')\n  el.appendChild(this.span)\n\n  this.text = 'Text'\n  this.prefix = ''\n  this.suffix = ''\n  this.updateContent()\n\n  Widget.call(this, grid, uuid, el)\n\n  this.w = 3\n  this.h = 1\n\n  this.el.style.justifyContent = this.align = 'center'\n  this.el.style.alignItems = this.valign = 'center'\n\n  this.fontSize = 12\n  this.span.style.fontSize = this.fontSize + 'pt'\n\n  this.color = '#000000'\n  this.background = ''\n}\n\nWidget.createSubclass(Text, {\n  text: new Prop(String, undefined, function (val) {\n    this.text = val\n    this.updateContent()\n  }),\n  fontSize: new Prop(Number, undefined, function (val) {\n    this.fontSize = val\n    this.span.style.fontSize = val + 'pt'\n  }),\n  color: new Prop(String, undefined, function (val) {\n    this.color = val\n    this.span.style.color = val\n  }).setIsColor(),\n  background: new Prop(String, undefined, function (val) {\n    this.background = val\n    this.el.style.backgroundColor = val\n  }).setIsColor(),\n  align: new Prop(String, undefined, function (val) {\n    this.align = val\n    this.el.style.justifyContent = val\n  }).setOptions(['flex-start', 'center', 'flex-end']),\n  valign: new Prop(String, undefined, function (val) {\n    this.valign = val\n    this.el.style.alignItems = val\n  }).setOptions(['flex-start', 'center', 'flex-end']),\n  prefix: new Prop(String, undefined, function (val) {\n    this.prefix = val\n    this.updateContent()\n  }),\n  suffix: new Prop(String, undefined, function (val) {\n    this.suffix = val\n    this.updateContent()\n  })\n})\n\nWidget.prototype.updateContent = function () {\n  this.span.innerHTML = this.prefix + this.text + this.suffix\n}\n"}}]);